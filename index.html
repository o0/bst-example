<!DOCTYPE html>
<html lang="ru" dir="ltr">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="./css/main.css">
  <link rel="stylesheet" href="./css/content.css">
  <title>Двоичные деревья</title>
  <script src="//scrollmagic.io/js/lib/greensock/TweenMax.min.js"></script>
  <script src="//scrollmagic.io/scrollmagic/uncompressed/ScrollMagic.js"></script>
  <script src="//scrollmagic.io/scrollmagic/uncompressed/plugins/animation.gsap.js"></script>
  <script src="//scrollmagic.io/scrollmagic/uncompressed/plugins/debug.addIndicators.js"></script>
</head>
<body>

<h1>Двоичные деревья</h1>

<section>
  <dl>
    <dt>Задача</dt>
    <dd>Найти порядковый номер для элемента в упорядоченном списке</dd>
  </dl>

  <p>Поиск места элемента в списке - базовая задача для разработчиков. Это может быть определение положения игрока в рейтинге, статистика игрока по фрагам в онлайн-игре или, например, поиск положения товара в списке, отсортированного по цене. Решим похожую задачу: найдём место новому футболисту в рейтинге десяти лучших игроков мира.</p>

  <figure class="image-centered">
    <img src="img/01-list/01.png">
  </figure>
</section>

<section>
  <p>Как правило, для создания списков в JS разработчики пользуются массивами. Это логично, ведь это базовая структура, которая представлена в движке JS и чтобы использовать другой вид списков, нужно проделать большую: написать заново все методы для работы со списком, протестировать их. Не всегда результат стоит затраченных усилий.

  <figure class="image-centered">
    <img src="img/01-list/02.png" height="160">
    <figcaption>
      <pre><code>const list = [94, 94, 92, 90, 90, 89, 88, 88, 87];</code></pre>
    </figcaption>
  </figure>

  <h2>Прямой перебор</h2>
  <p>Чтобы найти порядковый номер элемента в массиве JS, нужно воспользоваться прямым перебором: перебрать все элементы по порядку, сравнивая их с образцом.

  <p>По принципу прямого перебора работают методы <code>indexOf</code>, <code>find</code> и <code>findIndex</code>, встроенные во все массивы.

    <figure class="fullscreen-code fullscreen-code-vertical" id="linear-lookup">
      <div class="fullscreen-code-visual">
        <img src="img/02-linear-lookup/01.png" height="350">
      </div>

      <figcaption class="fullscreen-code-text">
        <pre><code><span class="highlighter active stage-1">const list = [94, 94, 92, 90, 90, 89, 88, 88, 87];</span>
<span class="highlighter stage-2">const newElement = 91;</span>
const indexOfNewElement = <span class="highlighter stage-3">list.findIndex(it => newElement < it)</span>;
<span class="highlighter stage-4">list.splice(indexOfNewElement, 0, newElement);</span></code></pre>
      </figcaption>
    </figure>

  <p>В худшем случае, если элемент находится в конце списка или его в списке нет, поиск займет столько же итераций, сколько элементов содержится в списке: в ходе поиска будет проверен каждый элемент списка.

  <p>Проблема такого решения в том, что производительность этого кода падает вместе с увеличением количества элементов в списке. Если список относительно небольшой и счет количества элементов идет на сотни, проблем быть не должно, но когда список становится большим и количество элементов начинает измеряться тысячами, чтобы вставить один элемент приходится проверять тысячу остальных.
</section>

<section>
  <h2>Двоичный поиск в массиве</h2>
  <p>Если список упорядочен и мы точно знаем, что элементы в нем отсортированы, можно использовать двоичный поиск, он заметно сокращает количество итераций, которое нужно провести, чтобы найти элемент.

  <p>Основная идея двоичного поиска - постоянное разделение списка пополам. Поиск начинается со среднего элемента. Первое сравнение, мы производим с элементом, который находится в середине списка. Список упорядочен, поэтому мы знаем, что все элементы, которые больше среднего находятся в левой части списка, а те элементы, которые меньше среднего - в правой.

  <blockquote>"Больше" или "меньше", это условные понятия: список может быть отсортирован в любом порядке и критерий сравнения может быть любым. Под "больше" подразумевается что один элемент стоит в списке раньше другого, а под "меньше" - что позже.</blockquote>

  <figure class="fullscreen-code fullscreen-code-vertical" id="binary-lookup">
    <div class="fullscreen-code-visual">
      <img src="img/03-binary-search/04.png" height="350">
    </div>

    <figcaption class="fullscreen-code-text">
      <p><span class="highlighter active stage-1">После первого сравнения, если мы не нашли нужный элемент, мы понимаем в какую сторону нам двигаться дальше</span>. <span class="highlighter stage-2">Если искомый элемент больше среднего, мы отправляемся в левую половину списка</span>, <span class="highlighter stage-3">а если меньше среднего - в правую</span><span class="highlighter stage-4"> и повторяем процедуру на ней: находим элемент посередине, сравниваем с ним и так далее</span>, <span class="highlighter stage-5">пока не найдем место для элемента</span>.</p>
    </figcaption>
  </figure>

  <p>Проблема двоичного поиска в массивах JS заключается в том, что, получая массив, мы не можем быть уверены в том, что он отсортирован. У объектов массива нет никаких признаков, которые бы показывали, отсортирован массив или нет и проверить порядок элементов можно только перебрав их все по порядку. Такое решение нам не подходит, потому что в этой ситуации мы опять возвращаемся к прямому перебору всех элементов списка в лучшем случае, а в худшем случае, чтобы алгоритм заработал, массив нужно отсортировать, что займет еще какое-то количество повторений.
</section>

<section>
  <p>Чтобы гарантировать, что двоичный поиск будет работать, мы можем перераспределить данные так, чтобы они были заведомо упорядоченными. Напишем структуру данных, которая будет гарантировать, что двоичный поиск будет работать правильно. Двоичный поиск всегда начинается с середины списка, поэтому первым в структуре поставим элемент, с которого начинается поиск.</p>

  <p>После сравнения с первым элементом в списке, у нас есть только два варианта: мы можем оказаться в левой части списка и сравнивать наше значение со средним значением левой части или мы можем оказаться в правой части и сравнивать значение со средним значением правой части.</p>

  <p>Мы можем записать для среднего элемента ссылки на те элементы, с которыми будет производиться сравнение после него: для середин левой и правой половины списков, а потом рекурсивно продолжим разбиение списка на половины, пока у нас не закончатся элементы.</p>

  <figure class="fullscreen-code fullscreen-code-horizontal" id="binary-tree-buildup">
    <div class="fullscreen-code-visual">
      <img src="img/04-binary-search-tree/01.png" width="600">
    </div>
    <figcaption class="fullscreen-code-text">
      <pre class="code stage-1 active"><code>const first = 90;</code></pre>
      <pre class="code stage-2"><code>const first = {
  val: 90,
  left: {
    val: 92,
  },
  right: {
    val: 88,
  },
};</code></pre>
      <pre class="code stage-3"><code>const first = {
  val: 90,
  left: {
    val: 92,
    left: {
      val: 94,
      left: {
        val: 94
      }
    },
    right: {
      val: 90,
    },
  },
  right: {
    val: 88,
    left: {
      val: 89,
    },
    right: {
      val: 88,
      right: {
        val: 87,
      },
    },
  },
};</code></pre>
      </figcaption>
    </figure>

  <p>Сделаем структуру единообразной, такой, чтобы все объекты были одинаковыми. Если объект крайний в поиске и после него некуда дальше идти, всё равно добавим ему поля <code>left</code> и <code>right</code>, но запишем в них <code>null</code>.</p>

  <p>В результате мы получили дерево, в корне у которого стоит элемент, с которого начинается поиск, а его потомки: элементы, по которым поиск продолжается. Из-за того, что у каждого узла только два потомка, то есть при поиске есть только два варианта развития событий, дерево называется двоичным или бинарным.

  <h3>Правила построения бинарного дерева</h3>
  <ul>
    <li>корень - элемент с которого начинается поиск
    <li>у каждого элемента ровно два потомка: левый и правый
    <li>левый потомок всегда меньше чем узел
    <li>правый потомок всегда больше чем узел
    <li>если у элемента нет левого или правого потомка, вместо него записывается null
  </ul>

  <p>Мы получили структуру, перемещение по которой идеально подходит для двоичного поиска: она заведомо упорядочена так, что поиск сработает, нам не нужно гадать, в правильном ли порядке находятся элементы, ведь мы сами расставили их так, как удобно нам для поиска.

  <p>Поиск элемента начинается с корня и всегда идет вниз. Если искомый элемент больше того, на котором мы находимся, нужно перейти в правую ветку дерева, если меньше - в левую.

  <p>Вставка производится точно так же как и поиск, с той разницей, что новая запись вставляется только на место null-листа.

  <figure class="fullscreen-code fullscreen-code-horizontal" id="binary-tree-insertion">
    <div class="fullscreen-code-visual">
      <img src="img/05-binary-search-tree-insertion/05.png" width="600">
    </div>
    <figcaption class="fullscreen-code-text">
      <pre class="stage-1 active"><code>const insert = (tree, value) => {
  if (value >= tree.val) {
    if (tree.left === null) {
      tree.left = {
        val: value,
        left: null,
        right: null,
      };
    } else {
      insert(tree.left, node);
    }
  } else {
    if (tree.right === null) {
      tree.right = {
        val: value,
        left: null,
        right: null,
      };
    } else {
      insert(tree.right, node);
    }
  }
}</code></pre>
    </figcaption>
  </figure>

  <p>Имплементация упорядоченного списка в виде двоичного дерева дает прирост скорости для записи и поиска элементов в списке относительно обычного массива. В зависимости от размеров списка, разница в скорости может быть стократной.

  <h3>Интерфейс списка</h3>
  <p>Любой список должен иметь интерфейс <code>forEach</code> для последовательного перебора элементов. В случае двоичного дерева эту задачу можно решить используя перебор внутренним порядком, по-английски он назвается Inorder. Работает он так:

  <ol>
    <li>Если у узла есть левый потомок, рекурсивно посещаем его
    <li>Посещаем узел
    <li>Если у узла есть правый потомок, рекурсивно посещаем его
  </ol>

  <figure class="fullscreen-code fullscreen-code-vertical" id="binary-inorder">
    <div class="fullscreen-code-visual">
      <img src="img/06-binary-search-tree-inorder/01.png" height="450">
    </div>

    <figcaption class="fullscreen-code-text">
      <pre><code>const inorder = (node, visit) => {
  <span class="highlighter active stage-1">if (node.left)</span> <span class="highlighter stage-2">inorder(node.left, visit);</span>
  <span class="highlighter stage-3">visit(node.val);</span>
  <span class="highlighter stage-4">if (node.right) inorder(node.right, visit);</span>
};</code></pre>
    </figcaption>
  </figure>

  <blockquote>Под посещением можно понимать любое действие, которое мы выполняем с элементом. Например, если мы перебираем дерево, чтобы вывести все его элементы по порядку, то посещением в этом случае будет команда вывода, например <code>console.log</code></blockquote>

  <p>Используя внутренний перебор, можно перебрать все элементы по порядку, несмотря на то, что хранятся они в другом порядке

  <figure class="fullscreen-code fullscreen-code-horizontal" id="binary-inorder-big">
    <div class="fullscreen-code-visual">
      <img src="img/07-binary-search-tree-inorder-big/01.png" width="600">
    </div>

    <figcaption class="fullscreen-code-text">
      <pre><code>const inorder = (node, visit) => {
  <span class="highlighter active stage-1">if (node.left)</span> <span class="highlighter stage-2">inorder(node.left, visit);</span>
  <span class="highlighter stage-3">visit(node.val);</span>
  <span class="highlighter stage-4">if (node.right) inorder(node.right, visit);</span>
};</code></pre>
    </figcaption>
  </figure>

  <h2>Сложности</h2>
  <h3>Удаление</h3>
  <p>Дерево работает гораздо лучше простого массива для поиска и вставки элементов, но когда дело доходит до удаления, могут начаться сложности. Если удаляемый элемент является листом дерева, то есть не имеет потомков, то удаление будет тривиальным, но сложноcти начинаются когда нужно удалить элемент с потомками: в этом случае нужно будет не просто убрать элемент, который мы хотим удалить, но и переставить другие элементы в дереве.

  <h3>Балансировка</h3>
  <p>Всегда существует несколько способов собрать дерево из одних и тех же элементов и какие-то способы могут оказаться неэффективными. Если вставить в дерево подряд все элементы по возрастанию, дерево превратится в простой список. Это не плохо, просто в этой ситуации теряются все преимущества бинарного поиска и никакого прироста в скорости относительно обычного массива не выйдет. Если хочется этого избежать, то нужно использовать балансировку: делать так, чтобы элементы в дереве стояли так, чтобы дерево не было слишком глубоким.

  <p>Чтобы сбалансировать дерево самым простым образом, сначала дерево нужно вытянуть в так называемую "лиану" - дерево, в котором у каждого элемента есть только правый потомок - а потом последовательно пройти по всем элементам дерева и "повернуть" их в левую сторону. Подробней, как делается левый поворот можно почитать в Википедии и в дополнительных материалах к этой статье.

  <p>Существуют вариации двоичных деревьев, которые называются самобалансирующимися. Самые популярные варианты таких деревьев: красно-чёрное и AVL-деревья. В них узлы содержат дополнительную информацию, которая помогает держать дерево сбалансированным.
</section>

<section>
  <h2>Выводы</h2>
  <p>Использование двоичных деревьев поиска для списков выгодно если список упорядочен, он достаточно большой и основные действия, которые производятся со списком - это вставка и поиск.

  <p>Список должен быть упорядоченным, чтобы на нём мог работать двоичный поиск. Если список состоит из случайных элементов, то никакого смысла использовать двоичное дерево нет: на случайных списках двоичный поиск работать не будет.

  <p>Список достаточно большой: преимущества двоичного поиска начинают проявляться на относительно больших списках. Незначительный прирост скорости будет ощущаться и на 100 элементах, но когда порядок доходит до 1000 прирост будет существенным и может оказаться стократным.

  <p>Основные действия, которые выполняются со списком: вставка и поиск элементов. Если список нужен для того, чтобы обращаться к его элементам по порядковому номеру, то массив будет удобней.

  <dl>
    <dt>Двоичное дерево</dt>
    <dd>Рейтинг игрока: топ-10 игроков, по количеству набранных очков; количество фрагов</dd>
    <dd>Список товаров, отсортированный по убыванию цены</dd>

    <dt>Массив</dt>
    <dd>История: история действий пользователя; </dd>
    <dd>Ситуации, когда обращение к элементу идёт по номеру</dd>
  </dl>
</section>

<section>
  <h2>Практика и дополнительные материалы (ссылки)</h2>
  <p>Код главы на CodePen
  <p>Библиотека для работы с бинарными деревьями на гитхабе
  <p>Ссылки на тесты производительности
  <p>Балансировка деревьев
  <p>Самобалансирующиеся деревья:
  <ul>
    <li>Красно-чёрное дерево
    <li>AVL-дерево
  </ul>
</section>

<script src="./js/animation.js"></script>

</body>
</html>
